import { traverseObjects as y, getPath as o } from "./helper.js";
const w = async (u, r, a) => {
  let e = r;
  e.length === 0 && (await u.listCollections()).forEach((c) => e.push(c.path));
  const t = e.map(
    (i) => C(u, i, a)
  ), f = await Promise.all(t);
  return Object.assign({}, ...f);
}, R = async (u, r, a, e) => {
  try {
    let t = {};
    t[r] = {};
    const c = [await u.collection(r).doc(a).get()];
    for (const s of c) {
      const l = await s.ref.listCollections();
      if (t[r][s.id] = s.data() || {}, e != null && e.refs) {
        for (const n of e == null ? void 0 : e.refs)
          if (n.indexOf(".") > -1)
            y(t, (d) => {
              var h;
              return ((h = d.constructor) == null ? void 0 : h.name) !== "DocumentReference" ? null : o(d);
            });
          else if (t[r][s.id][n])
            if (Array.isArray(t[r][s.id][n]))
              for (let d of t[r][s.id][n])
                t[r][s.id][n] = o(d);
            else typeof t[r][s.id][n].path == "string" && (t[r][s.id][n] = t[r][s.id][n].path);
      }
      if (l.length > 0) {
        t[r][s.id].subCollection = {};
        for (const n of l) {
          const d = await C(
            u,
            `${r}/${a}/${n.id}`,
            e
          );
          t[r][s.id].subCollection = {
            ...t[r][s.id].subCollection,
            ...d
          };
        }
      }
    }
    return t;
  } catch (t) {
    throw console.error(t), new Error(t.message);
  }
}, b = async (u, r, a, e) => {
  const t = await r.ref.listCollections();
  let f = Object.assign({}, r.data());
  if (e != null && e.refs) {
    for (const c of e == null ? void 0 : e.refs)
      if (c.indexOf(".") > -1)
        y(f, (s) => {
          var l;
          return ((l = s.constructor) == null ? void 0 : l.name) !== "DocumentReference" ? null : o(s);
        });
      else if (f[c])
        if (Array.isArray(f[c]))
          for (let s of f[c])
            f[c] = o(s);
        else typeof f[c].path == "string" && (f[c] = f[c].path);
  }
  if (t.length > 0) {
    f.subCollection = {};
    const c = { ...e };
    c != null && c.queryCollection && delete c.queryCollection;
    for (const s of t) {
      const l = await C(
        u,
        `${a}/${r.id}/${s.id}`,
        c
      );
      f.subCollection = {
        ...f.subCollection,
        ...l
      };
    }
  }
  let i = {};
  return i[r.id] = f, i;
}, C = async (u, r, a) => {
  try {
    let e = {};
    e[r] = {};
    const t = u.collection(r), f = (a == null ? void 0 : a.queryCollection) != null ? await a.queryCollection(t) : await t.get(), c = (((a == null ? void 0 : a.docsFromEachCollection) ?? 0) > 0 ? f.docs.slice(0, a == null ? void 0 : a.docsFromEachCollection) : f.docs).map(
      (l) => b(u, l, t.path, a)
    );
    return (await Promise.all(c)).forEach((l) => {
      e[r] = Object.assign(e[r], l);
    }), e;
  } catch (e) {
    throw console.error(e), new Error(e.message);
  }
};
export {
  b as backUpDocRef,
  R as backupFromDocService,
  C as backupService,
  w as getAllCollectionsService
};
