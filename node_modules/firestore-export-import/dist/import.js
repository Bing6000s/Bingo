import A from "fs";
import { v1 as C } from "uuid";
import { makeTime as h, traverseObjects as a, parseAndConvertDates as P, makeGeoPoint as g, parseAndConvertGeos as $ } from "./helper.js";
const G = (n, o, f) => new Promise(
  (e, r) => {
    typeof o == "object" ? m(n, o, f).then(() => {
      e({
        status: !0,
        message: "Collection successfully imported!"
      });
    }).catch((s) => {
      r({ status: !1, message: s.message });
    }) : A.readFile(o, "utf8", function(i, s) {
      i && (console.log(i), r({ status: !1, message: i.message }));
      let l = JSON.parse(s);
      m(n, l, f).then(() => {
        e({
          status: !0,
          message: "Collection successfully imported!"
        });
      }).catch((t) => {
        r({ status: !1, message: t.message });
      });
    });
  }
), m = async (n, o, f = {}) => {
  for (const e in o) {
    let r = e;
    for (const i in o[e])
      if (o[e].hasOwnProperty(i)) {
        let s = Array.isArray(o[e]) ? C() : i;
        if (Array.isArray(o[e])) {
          const l = o[e][i].subCollection;
          if (delete o[e][i].subCollection, await w(
            n,
            r,
            s,
            o[e][i],
            f
          ), l)
            for (const t in l) {
              const u = {}, c = `${r}/${s}/${t}`;
              u[c] = l[t], await m(n, u, f);
            }
        } else {
          const l = o[e][s].subCollection;
          delete o[e][i].subCollection;
          try {
            await w(
              n,
              r,
              s,
              o[e][i],
              f
            );
          } catch (t) {
            console.error(t);
          }
          l && await m(n, l, f);
        }
      }
  }
}, w = (n, o, f, e, r) => {
  var i;
  return r.dates && r.dates.length > 0 && r.dates.forEach((s) => {
    e.hasOwnProperty(s) && (Array.isArray(e[s]) ? e[s] = e[s].map((l) => h(l)) : e[s] = h(e[s])), s.indexOf(".") > -1 && a(e, (l) => l.hasOwnProperty("_seconds") ? h(l) : null);
  }), r.autoParseDates && P(e), (i = r.refs) != null && i.length && r.refs.forEach((s) => {
    e.hasOwnProperty(s) ? Array.isArray(e[s]) ? e[s] = e[s].map((l) => n.doc(l)) : e[s] = n.doc(e[s]) : e.hasOwnProperty(s.split(".")[0]) && s.split(".").reduce((l, t, u) => {
      if (Array.isArray(l))
        return l.reduce((c, y) => {
          if (typeof y[t] == "string")
            y[t] = n.doc(y[t]);
          else return typeof y[t] == "object" ? c = y[t] : c;
        }, {});
      if (Array.isArray(l[t]) && s.split(".").length === u + 1)
        l[t] = l[t].map((c) => n.doc(c));
      else return s.split(".").length === u + 1 && l[t] ? l[t] = n.doc(l[t]) : l[t] = l[t] || null;
    }, e);
  }), r.geos && r.geos.length > 0 && r.geos.forEach((s) => {
    e.hasOwnProperty(s) && (Array.isArray(e[s]) ? e[s] = e[s].map((l) => g(l)) : e[s] = g(e[s])), s.indexOf(".") > -1 && a(e, (l) => l.hasOwnProperty("_latitude") ? g(l) : null);
  }), r.autoParseGeos && $(e), new Promise((s, l) => {
    n.collection(o).doc(f).set(e).then(() => {
      r != null && r.showLogs && console.log(`${f} was successfully added to firestore!`), s({
        status: !0,
        message: `${f} was successfully added to firestore!`
      });
    }).catch((t) => {
      console.log(t), l({
        status: !1,
        message: t.message
      });
    });
  });
};
export {
  G as restoreService
};
